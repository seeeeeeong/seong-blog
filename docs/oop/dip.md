---
sidebar_position: 9
---

# DIP(Dependency Inversion Principle): 의존 역전 원칙

상위 모듈은 하위 모듈에 의존해서는 안된다. 추상화에 의존해야한다.
추상화는 구체적인 것에 의존해서는 안된다. 구체적인 것은 추상화에 의존해야한다.


  ```
class 아이폰 {
	fun 전화() {
		print(“call”);
	}
	fun 검색() {
		print(“search”);
	}
}
  ```

  ```
class 사용자 {
	val 내폰 = 아이폰();

	fun 전화() {
		내폰.전화()
	}
	fun 검색() {
		내폰.검색()
	}

}
  ```

사용자는 아이폰 클래스에 의존한다. 아이폰 클래스는 구체적인 클래스이므로 변화에 취약하다.
만약 사용자가 아이폰을 다른 스마트폰으로 바꾼다면 코드에 상당한 변화가 필요하다.

#### 추상화는 구체적인 것에 의존해서는 안된다. 구체적인 것은 추상화에 의존해야한다.

스마트폰이라는 추상화된 interface를 각종 구체화된 클래스들이 상속하고
사용자는 스마트폰 interface에 의존하도록 한다.

#### 상위 모듈은 하위 모듈에 의존해서는 안된다. 추상화에 의존해야한다.

```
interface 스마트폰 {
	fun 전화()
	fun 검색()
}
  ```

```
class 아이폰 : 스마트폰 {
	override fun 전화() {
		print(“call”);
	}
	override fun 검색() {
		print(“search”);
	}
}
  ```

```
class 사용자(내폰 : 스마트폰) {
	fun 전화() {
		내폰.전화()
	}
	fun 검색() {
		내폰.검색()
	}
}

// 실제 사용
val 나 = 사용자(object : 아이폰())
나.전화()
나.검색()

  ```

의존하는 클래스를 추상화하고 외부에서 주입,
외부 변동에 유연하게 대처할 수 있는 코드로 개선되었다.